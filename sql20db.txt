git CMD

git config -- global user.name "Daanel Dederer"
git config --global user.email "daaneldederer@gmail.com"
git config --global --list
git clone https://github.com/IrinaMerkulova/TITpv20
cd TITpv20
git branch DaanelD
git checkout DaanelD
git status

git push --set-upstream origin DaanelD


git add .
git commit -a -m "git commands are added"

git push 





-- db loomine
--create database TiTpv20

-- db kustutamine
--DRop DataBASE TiTpv20

--- teeme tabeli sugu ja isik
--create table Gender
--(
--Id int NOT NULL primary key,
--Gender nvarchar(10) not null
--)

--create table Person
--(
--Id int not null primary key,
--Name nvarchar(25),
--Email nvarchar(30),
--GenderId int
--)

--- andmete sisestamine tabelisse
-- insert into gender (id, gender)
-- values (1, 'female')
-- insert into gender (id, gender)
-- values (2, 'male')

--- nüüd saab kasutada ainult Gender tabelis olevaid väärtuseid
-- alter table person add constraint tblperson_genderid_fk
-- foreign key (genderid) references gender(id)

-- -- sisestame andmed
-- insert into person (id, name, email, genderid)
-- values (1, 'supermees', 's@s.com', 2)
-- insert into person (id, name, email, genderid)
-- values (2, 'wonderwoman', 'w@w.com', 1)
-- insert into person (id, name, email, genderid)
-- values (3, 'batman', 'b@b.com', 2)
-- insert into person (id, name, email, genderid)
-- values (4, 'aquaman', 'a@a.com', 2)
-- insert into person (id, name, email, genderid)
-- values (5, 'catwoman', 'c@c.com', 1)
-- insert into person (id, name, email, genderid)
-- values (6, 'antman', 'ant"ant.com', 2)
-- insert into person (id, name, email, genderid)
-- values (7, 'spiderman', 'spider@spiderman.com', 2)

-- vaatame tabeli andmeid
-- select * from person

-- * tabelid on täidetud andmetega

--- võõrvõtme piirangu maha võtmine
-- alter table person
-- drop constraint tblperson_genderid_fk

-- sisestame väärtuse tabelisse
-- insert into gender (id, gender)
-- values (3, 'unknown')
-- lisame võõrvõtme uuesti
-- alter table person
-- add constraint df_person_genderid
-- default 3 for genderid


---- 2 tund

-- select * from person
-- select * from gender

-- insert into person (id, name, email)
-- values (8, 'test', 'test')

---lisame uue veeru tabelisse
-- alter table person
-- add age nvarchar(10)

--uuendame andmeid
-- update person
-- set age = 149
-- where id = 8

-- -- veerule piirnagu panemine
-- alter table person
-- add constraint ck_person_age check (age > 0 and age < 150)

-- insert into person (id, name, email, genderid, age)
-- values (9, 'test', 'test', 2, 160)

--rea kustutamine
-- select * from person
-- go
-- delete from person where id = 8
-- go
-- select * from person

--- lisame veeru juurde
-- alter table person
-- add city nvarchar(25)

-- tahame tead kõiki, kes elavad Gothami linnas 
-- select * from person where city = 'gotham'
-- kõik, kes ei ela Gothamis
-- select * from person where city <> 'gotham'
-- select * from person where city != 'gotham'

-- -- näitab teatud vanusega inimesi
-- select *from person where age = 100 or 
-- age = 50 or age = 20
-- select * from person where age in (100, 50, 20)

-- --- näitab teatud vanusevahemikus olevaid inimesi
-- select * from person where age between 30 and 50

-- --- wildcard e näitab kõik g-tähega linnad
-- select * from person where city like 'n%'
-- select * from person where email like '%@%'

-- -- n'itab kõiki, kellel ei ole @-märki emailis
-- select * from person where email not like '%@%'

-- --- näitab, kelle on emailis ees ja peale @-märki
-- -- ainult üks täht
-- select * from person where email like '_@_.com'

-- --- kõik, kellel ei ole nimes esimene täht w, a ja s
-- select * from person where name like '[^was]%'

-- --- kes elavad gothamis ja new yorkis
-- select * from person where (city = 'gotham' or city = 'new york')

-- --- kõik, kes elevad välja toodud linnades ja on vanemad kui 40 a
-- select * from person where (city = 'gotham' or city = 'new york')
-- and age >= 40

-- -- kuvab tähestikulises järjekorras inimesi ja võtab aluseks name veeru
-- select * from person order by name
-- --- kuva vastupidises järjestuses
-- select * from person order by name desc

-- ---võtab kolm esimest rida
-- select top 3 * from person

-- --- kolm esimest, aga tabeli järjestus on age ja siis name
-- select * from person
-- select top 3 age, name from person

-- --- näitab esimesed 50% tabelis
-- select top 50 percent * from person

-- -- järjestab vanuse järgi isikud
-- select * from person order by cast(age as int)
-- select * from person order by age

-- -- kõikide isikute koondvanus
-- select sum(cast(age as int)) from person

-- --- kuvab kõige nooremat isikut
-- select min(cast(age as int)) from person
-- --- kõige vanem isik
-- select max(cast(age as int)) from person

-- select city, sum(cast(age as int)) as totalage from person group by city



--kõik select'id on tehtud

--- tund 3

--- loome uued tabelid
-- create table department
-- (
-- id int primary key,
-- departmentname nvarchar(50),
-- location nvarchar(50),
-- departmenthead nvarchar(50)
-- )

-- create table employees
-- (
-- id int primary key,
-- name nvarchar(50),
-- gender nvarchar(10),
-- salary nvarchar(50),
-- departmentid int
-- )

---sisestame andmed
-- insert into department (id, departmentname, location, departmenthead)
-- values (1, 'it', 'london', 'rick')
-- insert into department (id, departmentname, location, departmenthead)
-- values (2, 'payroll', 'delhi', 'ron')
-- insert into department (id, departmentname, location, departmenthead)
-- values (3, 'hr', 'new york', 'christie')
-- insert into department (id, departmentname, location, departmenthead)
-- values (4, 'other deparment', 'sydney', 'cindrella')

-- select * from department

-- insert into employees (id, name, gender, salary, departmentid)
-- values (1, 'tom', 'male', 4000, 1)
-- insert into employees (id, name, gender, salary, departmentid)
-- values (2, 'pam', 'female', 3000, 1)
-- insert into employees (id, name, gender, salary, departmentid)
-- values (3, 'john', 'male', 3500, 1)
-- insert into employees (id, name, gender, salary, departmentid)
-- values (4, 'sam', 'male', 4500, 2)
-- insert into employees (id, name, gender, salary, departmentid)
-- values (5, 'todd', 'male', 2800, 1)
-- insert into employees (id, name, gender, salary, departmentid)
-- values (6, 'ben', 'male', 7000, 1)
-- insert into employees (id, name, gender, salary, departmentid)
-- values (7, 'sara', 'female', 4800, 3)
-- insert into employees (id, name, gender, salary, departmentid)
-- values (8, 'valarie', 'female', 5500, 1)
-- insert into employees (id, name, gender, salary, departmentid)
-- values (9, 'james', 'male', 6500, null)
-- insert into employees (id, name, gender, salary, departmentid)
-- values (10, 'russell', 'male', 8800, null)

-- select * from employees

-- andmed on lisatud tabelitesse "employees" ja "department"

--- saan ainult selles tabelis olevad veerud
-- select distinct name, departmentid from employees

-- --- arvutame k]ikide palgad kokku
-- select sum(cast(salary as int)) from employees
-- --- k]ige v'iksema palga saaja
-- select min(cast(salary as int)) from employees


-- alter table employees
-- add city nvarchar(25)


-- alter table employees
-- add departmentid
-- int null


--- lisame tabelid
-- alter table employees
-- add middlename nvarchar(30)

-- alter table employees
-- add lastname nvarchar(30)

-- update employees set firstname = 'tom', middlename = 'nick', lastname = 'jones'
-- where id = 1
-- update employees set firstname = 'pam', middlename = null, lastname = 'anderson'
-- where id = 2
-- update employees set firstname = 'john', middlename = null, lastname = null
-- where id = 3
-- update employees set firstname = 'sam', middlename = null, lastname = 'smith'
-- where id = 4
-- update employees set firstname = null, middlename = 'todd', lastname = 'someone'
-- where id = 5
-- update employees set firstname = 'ben', middlename = 'ten', lastname = 'sven'
-- where id = 6
-- update employees set firstname = 'sara', middlename = null, lastname = 'connor'
-- where id = 7
-- update employees set firstname = 'valarie', middlename = 'balerine', lastname = null
-- where id = 8
-- update employees set firstname = 'james', middlename = '007', lastname = 'bond'
-- where id = 9
-- update employees set firstname = null, middlename = null, lastname = 'crowe'
-- where id = 10


--- igast reast võtab esimeses veerus täidetud lahtri ja kuvab ainult seda
-- select id, coalesce(name, middlename, lastname) as name
-- from employees

-- select * from employees
-- select * from department


--tund 3 on tehtud


--- loome stored procedure, mis kuvab vaate 
-- create procedure spgetemployees
-- as begin
	-- select firstname, gender from employees
-- end
 
-- spgetemployees
-- exec spgetemployees 
-- execute spgetemployees

--- 
-- create proc spgetemployeesbygenderanddepartment
-- @gender nvarchar(20),
-- @departmentid int
-- as begin
	-- select firstname, gender, departmentid from employees where gender = @gender
	-- and departmentid = @departmentid
-- end

--- kõik esimeses osakonnas meessoost töötavad isikud
-- spgetemployeesbygenderanddepartment 'male', 1

-- spgetemployeesbygenderanddepartment @departmentid =  1, @gender = 'male'




-- create proc spgetemployeecountbygender
-- @gender nvarchar(20),
-- @employeecount int output
-- as begin
	-- select @employeecount = count(id) from employees where gender = @gender
-- end

-- annab teada, palju on meessoost isikuid ning kuvab vastava stringi
-- declare @totalcount int
-- exec spgetemployeecountbygender 'female', @totalcount out
-- if(@totalcount = 0)
	-- print '@totalcount is null'
-- else
	-- print '@totalcount is not null'
-- print @totalcount

-- annab teada, palju on meessoost isikuid
-- declare @totalcount int
-- exec spgetemployeecountbygender @employeecount = @totalcount out, @gender = 'male'
-- print @totalcount

---- annab kogu tabeli ridade arvu
-- create proc sptotalcount2
-- @totalcount int output
-- as begin
	-- select @totalcount = count(id) from employees
-- end
--- käivitame sp
-- declare @totalemployees int
-- execute sptotalcount2 @totalemployees output
-- select @totalemployees

--- mis id all on keegi nime järgi
-- create proc spgetnamebyid1
-- @id int,
-- @firstname nvarchar(50) output
-- as begin
	-- select @firstname = firstname from employees where id = @id
-- end

--- käivitame sp
-- declare @firstname nvarchar(50)
-- execute spgetnamebyid1 6, @firstname output
-- print 'name of the employee = ' + @firstname


-- create proc spgetnamebyid2
-- @id int
-- as begin
	-- return (select firstname from employees where id = @id)
-- end
-- tuleb veatead kuna kutsusime välja int-i, aga Tom on string
-- declare @employeename nvarchar(50)
-- exec @employeename = spgetnamebyid2 1
-- print 'name of the employee = ' + @employeename

-- select * from employees

--tund 4 --- trigger

-- triggereid on kolme tüüpi
--1. DML trigger
--2. DDL trigger
--3. LOGON trigger

--- trigger on eriliik stored procedure-st. Kui mingi tegevus leiab andmebaasis aset,
--- siis serveris tehakse ka midagi.

--- DML - data manipulation manipulation
--- DML-i peamised käsud: Insert, Update ja Delete

-- after trigger:  käivitub peale mingit tegevust
-- instead trigger: käivitub enne triggeri tegevuse toimumist
create database TITpv22

create table EmployeeTrigger
(
Id int primary key,
Name varchar(30),
Salary int,
Gender nvarchar(10),
DepartmentId int
)


insert into EmployeeTrigger values(1, 'John', 5000, 'Male', 3)
insert into EmployeeTrigger values(2, 'Mike', 3400, 'Male', 2)
insert into EmployeeTrigger values(3, 'Pam', 6000, 'Female', 1)
insert into EmployeeTrigger values(4, 'Todd', 4800, 'Male', 4)
insert into EmployeeTrigger values(5, 'Sara', 3200, 'Female', 1)
insert into EmployeeTrigger values(6, 'Ben', 4800, 'Male', 3)

create table EmployeeAudit
(
Id int identity(1, 1) primary key,
AuditData nvarchar(1000)
)


--- nüüd teeme triggeri, et kui sisestan uue töötaja EmployeeTrigger tabelisse,
--- siis EmployeeAudit tabelisse tulevad andmed

--trigger
create trigger tr_Employee_ForInsert
on EmployeeTrigger
for insert
as begin
	declare @Id int
	select @Id = Id from inserted

	insert into EmployeeAudit
	values('New employee with Id = ' + cast(@Id as nvarchar(5)) 
	+ ' is added at ' + cast(Getdate() as nvarchar(20)))
end

insert into EmployeeTrigger values(7, 'Jimmy', 1800, 'Male', 3)

select * from EmployeeAudit

--- peale kustutamist tekiks info EmployeeAudit tabelisse
create trigger EmployeeForDelete
on EmployeeTrigger
for delete
as begin
	declare @Id int
	select @Id = Id from deleted
	
	insert into EmployeeAudit
	values('An existing employee with Id = ' + CAST(@Id as nvarchar(5))
	+ ' is deleted at ' + cast(GETDATE()as nvarchar(20)))
end

delete from EmployeeTrigger where Id = 7

select * from EmployeeAudit

--- after trigger
-- kasutavad kahte tabelit, milleks on INSERTED ja DELETED

-- after trigger näide
create trigger trEmployeeForUpdate
on EmployeeTrigger
for update
as begin
	select * from deleted
	select * from inserted
end

update EmployeeTrigger set Name = 'Todd', Salary = 2345,
Gender = 'Male' where Id = 4


--- teeme update triggeri korda
create trigger trEmployeeForUpdate
on EmployeeTrigger
for update
as begin
	-- deklareerisime muutujad, mida hakkame kasutama
	Declare @Id int
	declare @OldName nvarchar(30), @NewName nvarchar(30)
	declare @OldSalary int, @NewSalary int
	declare @OldGender nvarchar(10), @NewGender nvarchar(10)
	declare @OldDeptId int, @NewDeptId int
	-- muutuja, millega hakkame ehitama audit build-i
	declare @AuditString nvarchar(1000)
	-- sisestab andmed temp table-sse
	select * into #TempTable
	from inserted

	while(exists(select Id from #TempTable))
	begin
		-- tühja stringi initsialiserimine
		Set @AuditString = ''

		-- selekteerime esimese rea andmed temp table-st 
		select top 1 @Id = Id, @NewName = Name,
		@NewGender = Gender, @NewSalary = Salary,
		@NewDeptId = DepartmentId
		from #TempTable

		-- selekteerib käesoleva rea kustutatud tabelist
		select @OldName = Name,
		@OldGender = Gender, @OldSalary = Salary,
		@OldDeptId = DepartmentId
		from deleted where Id = @Id

		--- ehitame audit stringi dünaamiliseks
		set @AuditString = 'Employee with Id = ' + cast(@Id as nvarchar(4))
		+ ' changed '

		if(@OldName <> @NewName)
			set @AuditString = @AuditString + ' Name from ' + @OldName + ' to '
			+ @NewName

		if(@OldGender <> @NewGender)
			set @AuditString = @AuditString + ' Gender from ' + @OldGender + ' to '
			+ @OldGender

		if(@OldSalary <> @NewSalary)
			set @AuditString = @AuditString + ' Salary from ' 
			+ CAST(@OldSalary as nvarchar(10))
			+ ' to ' + CAST(@NewSalary as nvarchar(10))

		if(@OldDeptId <> @NewDeptId)
			set @AuditString = @AuditString + ' DepartmentId from ' 
			+ CAST(@OldDeptId as nvarchar(10))
			+ ' to ' + CAST(@NewDeptId as nvarchar(10))

		insert into EmployeeAudit values(@AuditString)

		-- kustutab kogu info temp table-st
		delete from #TempTable where Id = @Id
	end
end

select * from EmployeeTrigger

update EmployeeTrigger set Name = 'Todd123', Salary = 3456,
Gender = 'Female', DepartmentId = 3 
where Id = 4

select * from EmployeeTrigger
select * from EmployeeAudit


create table Department
(
Id int primary key,
DeptName nvarchar(20)
)

insert into Department values(1, 'IT')
insert into Department values(2, 'Payroll')
insert into Department values(3, 'HR')
insert into Department values(4, 'Admin')


-- enne triggeri tegemist tuleb teha vaade
create view vEmployeeDetails
as
select EmployeeTrigger.Id, Name, Gender, DeptName
from EmployeeTrigger
join Department
on EmployeeTrigger.DepartmentId = Department.Id



---- instead of insert trigger
create trigger trEmployeeDetailsInsteadOfInsert
on vEmployeeDetails
instead of insert
as begin
	declare @DeptId int

	select @DeptId = Department.Id
	from Department 
	join inserted
	on inserted.DeptName = Department.DeptName

	if(@DeptId is null)
	begin
		raiserror('Invalid Department Name. Statement terminated', 16, 1)
		return
	end

	insert into EmployeeTrigger(Id, Name, Gender, DepartmentId)
	select Id, Name, Gender, @DeptId
	from inserted
end
--- raiserror funktsioon
-- selle eesmärk on välja tuua veateade, kui DepartmentName veerus ei ole väärtust
-- ja ei ühti sisestatud väärtusega
-- esimene parameeter on veateate sisu, teiene on veatase (nr 16 tähendab üldiseid vigu),
-- kolmas on veaolek

insert into vEmployeeDetails values(7, 'Valarie', 'Female', 'assd')

delete from EmployeeTrigger where Id = 7
--- 10 tund SQL
select * from EmployeeTrigger
select * from vEmployeeDetails


update vEmployeeDetails
set DeptName = 'Payroll'
where Id = 2

--- teeme vaate
alter view vEmployeeDetailsUpdate
as
select EmployeeTrigger.Id, Name, Salary, Gender, DeptName
from EmployeeTrigger
join Department
on EmployeeTrigger.DepartmentId = Department.Id

select * from vEmployeeDetailsUpdate
update EmployeeTrigger set DepartmentId = 4
where Id = 4

--- loome triggeri
alter trigger trEmployeeDetailsInsteadOfUpdate
on vEmployeeDetailsUpdate
instead of update
as begin
	if(update(Id))
	begin
		raiserror('Id cannot be changed', 16, 1)
		return
	end

	if(UPDATE(DeptName))
	begin
		declare @DeptId int
		select @DeptId = Department.Id
		from Department
		join inserted
		on inserted.DeptName = Department.DeptName

		if(@DeptId is null)
		begin
			raiserror('Invalid Department Name', 16, 1)
			return
		end

		update EmployeeTrigger set DepartmentId = @DeptId
		from inserted
		join EmployeeTrigger
		on EmployeeTrigger.Id = inserted.Id
	end

	if(update(Gender))
	begin
		update EmployeeTrigger set Gender = inserted.Gender
		from inserted
		join EmployeeTrigger
		on EmployeeTrigger.Id = inserted.Id
	end

	if(UPDATE(Name))
	begin
		update EmployeeTrigger set Name = inserted.Name
		from inserted
		join EmployeeTrigger
		on EmployeeTrigger.Id = inserted.Id
	end

	if(UPDATE(Salary))
	begin
		update EmployeeTrigger set Salary = inserted.Salary
		from inserted
		join EmployeeTrigger
		on EmployeeTrigger.Id = inserted.Id
	end
end

select * from EmployeeTrigger

update vEmployeeDetailsUpdate
set Name = 'Johny', Gender = 'Female', DeptName = 'IT'
where Id = 1


--- delete trigger

create trigger trEmployeeDetails_InsteadOfDelete
on vEmployeeDetails
instead of delete
as begin
	delete EmployeeTrigger
	from EmployeeTrigger
	join deleted
	on EmployeeTrigger.Id = deleted.Id
end

delete from vEmployeeDetails where Id = 2
--- kui seda triggerit ei oleks, siis annaks veateate



